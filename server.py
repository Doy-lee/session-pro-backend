'''
Overview
  This file is the HTTP layer which declares the functions that serve the routes for interacting
  with the Session Pro Backend. These routes are registered onto a Flask application which enable
  the endpoints for the server.

  The role of this layer is to intercept and sanitize the HTTP request, extracting the JSON into
  valid, strongly typed (to Python's best ability) types that can be passed into the backend.

  The backend is responsible for further validation of the request such as signature verification
  and consistency against the state of the DB. If successful the result is returned back to this
  layer and piped back to the user in the HTTP response.

API
  All response endpoints follow the basic structure for success and failure respectively:

  { "status": 0, "result": { "version": 0, <content...> }}                          // On success
  { "status": 1, "errors": [ "1st reason for error", "2nd reason for error", ... ]} // On failure

  Which means that calling code should conditionally handle a root level `result` or `errors` type
  payload based on the status. `0` for success and non-`0` for failures.

  All routes accept v4 onion requests under the endpoint /oxen/lsrpc/v4

  /add_pro_payment
    Description
      Register a new payment identified by the payment details specified in the 'payment_tx' (e.g.:
      Google Play Store and the payment token) to the Session Pro back-end.

      The master public key `master_pkey` should be the deterministically derived Ed25519 public key
      from the user's Session Account seed. The rotating public key `rotating_pkey` should be an
      independent Ed25519 key that will be authorised to use the proof.

      The embedded `master_sig` and `rotating_sig` signature must sign over a 32 byte hash of the
      request components (in little endian) for example:

        google_hash = blake2b32(person='SeshProBackend__', version || master_pkey || rotating_pkey || payment_tx.provider || payment_tx.google_payment_token)
        apple_hash  = blake2b32(person='SeshProBackend__', version || master_pkey || rotating_pkey || payment_tx.provider || payment_tx.apple_tx_id)

      This request will fail if the Session Pro backend has not witnessed the equivalent payment
      independently from the storefront that the payment originally came from.

      The generated proof is signed by the Session Pro Backend. See `/get_pro_proof` comments for
      details on how to verify the proofs were generated by an authoritative Session Pro Backend.

    Request
      version:       1 byte, current version of the request which should be 0
      master_pkey:   32 byte Ed25519 public key derived deterministic from the Session Account seed
                     in hex
      rotating_pkey: 32 byte Ed25519 public key to pair to the pro proof in hex
      payment_tx:    Object containing fields about the purchase from the payment provider to
                     register for a Session Pro subscription.
        provider:             1 byte integer representing the platform that the payment to be
                              registered is coming from with the following mapping:
                                1 => Google Play Store
                                2 => Apple iOS App Store
        apple_tx_id:          When provider is set to Apple iOS App Store, set this field to the
                              transaction ID string.
        google_payment_token: When provider is set to the Google Play Store, set this field to the
                              purchase token string.
      master_sig:    64 byte signature over the hash of the contents of the request proving that the
                     user knows the secret component to the `master_pkey` and hence the caller is
                     authorised to pair a new `rotating_pkey` to this payment
      rotating_sig:  64 byte signature over the contents of the request proving that the user knows
                     the secret component to the `rotating_pkey`

    Response
      version:           1 byte version value from the request
      expiry_unix_ts_ms: 8 byte UNIX time-stamp of when the proof will expire
      gen_index_hash:    32 byte hash of the internal generation index that has been allocated to
                         the user. This hash is the unique identifier for all Session Pro Proofs
                         generated for a given payment.
      rotating_pkey:     32 byte Ed25519 public key authorised to use the proof
      sig:               64 byte signature over the proof, signed by the Session Pro backend allowing
                         third-parties to verify that the proof was generated by a authoritative
                         back-end.

    Example
      Request
      {
        "version": 0,
        "master_pkey": "077deae803d9b55c6b75e36729cb2034ad459d9ff85f821905b5eddb0d48cc60",
        "rotating_pkey": "3cf5193d27a91dd6f53ba30f032135688d8c5f168dee76c4d6206778c862597e",
        "payment_tx": {
            "provider": 1,
            "google_payment_token": "d0cce0ee860616d20cd0ddce86782607331530d628fa994c84689eb40b92be2c",
        }
        "master_sig": "f56c5f685ce6ab7a3775ce581b9e634fbd6358dab085698ccb3ba125c19dda341f8c7a5497268f1fb39874df4e6e4d6552cf984a3d50976b2004f8723d505707",
        "rotating_sig": "fcbe180c96d6b563ae50db48418f7b292d952dcbcdad78a09e74274024a2d79d148d4c16fc52eda2994f78887d4ec95e38e38d2f10547cae03efd41c409a3e01"
      }

      Response
      {
        "result": {
          "expiry_unix_ts_ms": 1761004800000,
          "gen_index_hash": "a89e5ca2b7c0d36da920b88ae7f4c833f26a41df6291649d2e11aea81217fe72",
          "rotating_pkey": "3cf5193d27a91dd6f53ba30f032135688d8c5f168dee76c4d6206778c862597e",
          "sig": "90db1086e810606cceafb9641584434a711a3989863b270b5a2e6dd9ed44d90996da8c7b0f0d457836dbe21ab41f66f964786817b7a1da398974a5db12e38702",
          "version": 0
        },
        "status": 0
      }

  /get_pro_proof
    Description
      Pair a new `rotating_pkey` to a pre-existing Session Pro payment, generating a new proof that
      can be attached to messages to enable entitlement to Pro features on the Session Protocol. The
      `master_pkey` public key must currently have an active subscription/payment associated with it
      for this request to succeed.

      The embedded `master_sig` and `rotating_sig` signature must sign over a 32 byte hash of the
      request components (in little endian):

        hash = blake2b32(person='SeshProBackend__', version || master_pkey || rotating_pkey || unix_ts_ms)

      Once the response has been received, the caller should store the proof offline and embed it
      into their messages on the Session Protocol, signing the message with their rotating secret
      key for other users to validate the proof and receive entitlement to Session Pro features.

      The generated proof is signed by the Session Pro Backend. The public keys of the backend will
      be published to allow third parties to authorise the validity of a proof's origin. The
      signature in the response signs over a 32 byte hash of the following response components (in
      little endian):

        hash = blake2b32(person='SeshProBackend__', version || gen_index_hash || rotating_pkey || expiry_unix_ts_ms)

    Request
      version:       1 byte, current version of the request which should be 0
      master_pkey:   32 byte Ed25519 public key derived deterministic from the Session Account seed
                     in hex
      rotating_pkey: 32 byte Ed25519 public key to pair to the pro proof in hex
      unix_ts_ms:    8 byte current UNIX timestamp
      master_sig:    64 byte signature over the hash of the contents of the request proving that the
                     user knows the secret component to the `master_pkey` and hence the caller is
                     authorised to pair a new `rotating_pkey` to the payment associated with the
                     `master_pkey`.
      rotating_sig:  64 byte signature over the contents of the request proving that the user knows
                     the secret component to the `rotating_pkey`.

    Response
      version:           1 byte version value from the request
      expiry_unix_ts_ms: 8 byte UNIX timestamp of when the proof will expire
      gen_index_hash:    32 byte hash of the internal generation index that has been allocated to the
                         user.
      rotating_pkey:     32 byte Ed25519 public key authorised to use the proof
      sig:               64 byte signature over the proof, signed by the Session Pro backend allowing
                         third-parties to verify that the proof was generated by a authoritative
                         backend.

    Examples
      Request
      {
        "version": 0,
        "master_pkey": "2a87bf679678fe7ccad36ae081de58ee327f1a6706d1f2b2ecda52219b7ee8bf",
        "rotating_pkey": "67917f7507c58880c50e249afecb2fe4a236d422c7e05b04d4fbf46e30c965d5",
        "unix_ts_ms": 1755648412000,
        "master_sig": "76e02d201fad147a318aa798196bf9880bf4425f529e24bb25af34a4181365ef7591ae066b31aded05e3b67370892f381910fcaf3c2ffb5be13cca389a572108",
        "rotating_sig": "74ffec4d91caf777d439f2f34a1c7375ff746ae798181bf357050f7848fd8b7f100a933b61e15f13cacdbd6028b37bc1f2a4d8888b2b04a6e5d7e51b38dd360e"
      }

      Response
      {
        "result": {
          "expiry_unix_ts_ms": 1758412800000,
          "gen_index_hash": "084563482babfdf1acda66fcef7c70ad835e148ab98f26371ce9e4abef6104d7",
          "rotating_pkey": "67917f7507c58880c50e249afecb2fe4a236d422c7e05b04d4fbf46e30c965d5",
          "sig": "a1ea79c2a274afc0a61e5946976297b42e1dcfdbde29f007c8fe43d2e616fc7e5db5865d05212e392a6395fabe1ed69f976fb19c25f4640df5b89a5870739e0e",
          "version": 0
        },
        "status": 0
      }

  /get_pro_revocations
    Description
      Retrieve the list of revoked Session Pro Proofs. Proofs are signed can be validated offline in
      perpetuity until expiry. There are situations where a current circulating and valid proof can
      be invalidated (for example a user has refunded their subscription). The Session Pro Backend
      maintains the list of proofs that callers can retrieve to reject proofs that circulating on
      the network.

      This endpoint accepts a `ticket` which represents the current iteration of the revocation
      list. The Session Pro Backend increments the ticket monotonically with each change to the
      revocation list. The caller submits their latest known `ticket` (which initially will be 0)
      and in the response the latest `ticket` known by the backend will be returned.

      By having the caller cache the ticket and reuse it in subsequent requests, the backend will
      only return the revocation list contents if the user's `ticket` is different from the
      backend's ticket.

      A revocation identifies a Session Pro proof using the `gen_index_hash` of the proof. This
      `gen_index_hash` is shared across all proofs for a user that were generated using the same
      payment, in other words there can be more than one proof circulating with this
      `gen_index_hash`. Callers must take care to reject all proofs they witness that match the
      `gen_index_hash` irrespective of any other common information in the proof.

      Note that expired proofs do not get revoked and will not show up in this list. It's the
      caller's responsibility to reject proofs that have expired by checking the expiry timestamp.
      Hence this endpoint is recommended to be called every hour from the caller's startup time as
      revocations are only created in exceptional circumstances (such as refunds or protocol
      mandated revocations, e.g.: rare).

    Request
      version: 1 byte, current version of the request which should be 0
      ticket:  4 byte monotonic integer that represents the current iteration of the revocation list
               held by the caller. Initially callers will set this to 0 if they do not know the
               latest ticket. In subsequent requests the latest known `ticket` should be passed in
               so that the backend only returns the updated revocation list if the contents of said
               list has changed.

    Response
      ticket:  4 byte integer of the latest ticket for the current revocation list of the Session
               Pro backend. If this value is the same as the request's `ticket` then the list will
               be empty as there are no changes to the revocation list.
      items:   Array of revocations, can be empty if there are no revocations or the request ticket
               is the latest ticket managed by the backend.
        expiry_unix_ts_ms: 8 byte UNIX timestamp indicating when the Session Pro Proof identified by
                           its `gen_index_hash` should be rejected until.
        gen_index_hash:    32 byte hash of the Session Pro proof that has been revoked.

    Examples
      Request
      { "version": 0, "ticket": 0 }

      Response
      {
        "result": {
          "items": [
            { "expiry_unix_ts_ms": 1758412800000, "gen_index_hash": "3ab824a62d2b6004449d44962383294a5e6e833d6ed491930fbba726a2569c68" }
          ],
          "ticket": 1,
          "version": 0
        },
        "status": 0
      }

  /get_pro_status
    Description
      Retrieve the list of current and historical payments associated with the Session Pro master
      public key. The returned list is in descending order from the date that the payment was
      registered (e.g.: newest payment to oldest).

      This request is paginated, initially the caller should pass the 0th page. The response will
      have the total number of pages at which the caller can query more pages if there are any to
      retrieve more payments.

      The embedded `master_sig` signature must sign over the 32 byte hash of the requests contents
      (in little endian):

        hash = blake2b32(person='SeshProBackend__', version || master_pkey || unix_ts_ms || page)

      TODO: In future we plan to prune payment history after some legally required threshold such as
      a year.

    Request
      version:     1 byte, current version of the request which should be 0
      master_pkey: 32 byte Ed25519 public key derived deterministic from the Session Account seed in
                   hex to get pro status for
      master_sig:  64 byte signature over the hash of the contents of the request proving that the
                   user knows the secret component to the `master_pkey` and hence the caller is
                   authorised to get pro status for this key.
      unix_ts_ms:  8 byte UNIX timestamp of the current time.
      history:     1 byte bool that when set to true enables retrieval of payment history which is
                   populated into the `items` of the response.

    Response
      status:   1 byte integer describing the current Session Pro entitlement of the associated key
                with the following mapping:
                  0 => Never Been Pro
                       User has never purchased/redeemed a Session Pro payment for the associated
                       master public key. Accordingly, the items array will be empty.
                  1 => Active
                       User has a Session Pro payment that is actively being consumed for
                       entitlement to Session Pro features.
                  2 => Expired
                       User had Session Pro payment(s) that were fully consumed previously and
                       currently don't have an active payment and hence entitlement to Session Pro
                       features.
      auto_renewing:     1 byte boolean indicating if the latest pro subscription (if active)
                         is set to auto-renew at the marked expiry time.
      expiry_unix_ts_ms: 8 byte UNIX timestamp indicating when the entitlement of Session
                         Pro is due to expire as defined by the payment with the latest
                         expiry date associated with it.
      grace_duration_ms: 8 byte duration integer indicating the grace period duration indicating
                         the amount of time the payment platform will attempt to auto-renew the
                         subscription after it has expired. The user is entitled to Session Pro
                         during this period, `expiry_unix_ts_ms + grace_period_duration_ms` if
                         `auto_renewing` is true. Clients can request a proof for users in a grace
                         period that expires at the end of the grace period. This value is 0 if
                         `auto_renewing` is false.
      items:    Array of payments associated with `master_pkey`. Payments are returned in descending
                order by the payment date
        status:                   1 byte integer describing the status of the consumption of the
                                  payment for Session Pro with the following mapping:
                                    2 => Redeemed
                                         Payment was recognised by the backend and is being used for
                                         Session Pro entitlement.
                                    3 => Expired
                                         Session Pro entitlement has expired and is no longer being
                                         provided for this payment
                                    4 => Revoked
                                         User has successfully refunded/or had their payment revoked
                                         and Session Pro entitlement is no longer available

                                  Always check the status before interpreting the fields. It's
                                  possible to transition from revoked -> redeemed for example if the
                                  payment provider cancels a refund in which case the revoked
                                  timestamp is set but the payment is actually being actively
                                  consumed.
        plan:                     1 byte integer indicating the Session Pro plan that was purchased
                                  with the following mapping:
                                    1 => 1  Month
                                    2 => 3  Months
                                    3 => 12 Months
        payment_provider:         1 byte integer representing the platform that the payment to be
                                  registered is coming from with the following mapping:
                                    1 => Google Play Store
                                    2 => Apple iOS App Store
        auto_renewing:            1 byte boolean representing if the user had auto-renewing enabled
                                  to repeat this payment. It additionally indicates that the user is
                                  to be granted the grace period marked on the payment.
        unredeemed_unix_ts_ms:    8 byte UNIX timestamp indicating when the payment was executed.
        redeemed_unix_ts_ms:      8 byte UNIX timestamp indicating when the payment was registered.
                                  This timestamp is rounded up to the next day boundary from the
                                  actual registration date.
        expiry_unix_ts_ms:        8 byte UNIX timestamp indicating when the entitlement of Session
                                  Pro is due to expire.
        grace_period_duration_ms: 8 byte duration integer indicating how long the subscription's
                                  grace period is. Set to 0 if auto-renewing is disabled.
        platform_refund_expiry_unix_ts_ms: 8 byte unix timestamp indicating when the payment will no
                                           longer be eligible for a refund via its purchase
                                           platform.
        revoked_unix_ts_ms:                8 byte UNIX timestamp indicating when the payment was
                                           revoked. 0 if it never revoked.
        google_payment_token:    When payment provider is Google Play Store, a string which is set
                                 to the platform-specific purchase token for the subscription.
        google_order_id:         When payment provider is Google Play Store, a string which is set
                                 to the platform-specific order ID for the subscription.
        apple_original_tx_id:    When payment provider is Apple iOS App Store, a string which is set
                                 to the platform-specific original transaction ID for the
                                 subscription.
        apple_tx_id:             When payment provider is Apple iOS App Store, a string which is set
                                 to the platform-specific transaction ID for the subscription.
        apple_web_line_order_id: When payment provider is Apple iOS App Store, a string which is set
                                 to the platform-specific transaction web line order ID for the
                                 subscription.

    Examples
      Request
      {
        "version": 0,
        "master_pkey": "8ddc57b457fca85d2184813ea18a048f64a35ab0e693d4a0a3e4f8ee87ff3360",
        "master_sig": "37495dfab72772ebf4e4bf213b0a1c46e8e044ef3e4360ff8ef04ee8a7daf2178a716447de6f938d0e7865be31735fb2db2d1213dc35c02dfe253aac77fb2a0d",
        "timestamp": 1755653705,
        "history": true,
      }

      Response
      {
        "result": {
          "items": [
            {
              "status": 2,
              "subscription_duration_s": 2592000
              "payment_provider": 1,
              "expiry_unix_ts_ms": 1761718134941,
              "grace_period_duration_ms": 0,
              "platform_refund_expiry_unix_ts_ms": 1761718134941,
              "redeemed_unix_ts_ms": 1759190400000,
              "revoked_unix_ts_ms": 0,
              "google_order_id": "993f7d1bbcf4dfda482a8bce4f2b62acfc8c2d3d06b6512dfc981738ddf85562490b016f27b07a17c080c0765ada43f2e4c0618196f667e1174d1b3d67752b86",
              "google_payment_token": "ad8b67960eb91e8e2c0a4e8f191ea77b5ad593508b52ecc36c69c059cab39397fbf1e96142fa7fbcc7391cc3369ad110e3f9cbfccef284a925dcd470a4670aec",
            }
          ],
          "latest_expiry_unix_ts_ms": 1761782400000,
          "latest_grace_unix_ts_ms": 0,
          "status": 1,
          "version": 0
        },
        "status": 0
      }
'''

import flask
import typing
import time
import nacl.signing
import nacl.bindings
import nacl.public
import collections.abc
import hashlib
import json
import dataclasses
import enum

import base
import backend
from vendor import onion_req

@dataclasses.dataclass
class GetJSONFromFlaskRequest:
    json:    dict[str, base.JSONValue] = dataclasses.field(default_factory=dict)
    err_msg: str                       = ''

class UserProStatus(enum.IntEnum):
    NeverBeenPro = 0
    Active       = 1
    Expired      = 2

# Keys stored in the flask app config dictionary that can be retrieved within
# a request to get the path to the SQLite DB to load and use for that request.
FLASK_CONFIG_DB_PATH_KEY        = 'session_pro_backend_db_path'
FLASK_CONFIG_DB_PATH_IS_URI_KEY = 'session_pro_backend_db_path_is_uri'

# Name of the endpoints exposed on the server
FLASK_ROUTE_ADD_PRO_PAYMENT     = '/add_pro_payment'
FLASK_ROUTE_GET_PRO_PROOF       = '/get_pro_proof'
FLASK_ROUTE_GET_PRO_REVOCATIONS = '/get_pro_revocations'
FLASK_ROUTE_GET_PRO_STATUS      = '/get_pro_status'

RESPONSE_SUCCESS          = 0

# How many seconds can the timestamp in the get all payments route can drift
# from the current server's timestamp before it's flat out rejected
GET_ALL_PAYMENTS_MAX_TIMESTAMP_DELTA_MS = 5 * 1000

# The object containing routes that you register onto a Flask app to turn it
# into an app that accepts Session Pro Backend client requests.
flask_blueprint = flask.Blueprint('session-pro-backend-blueprint', __name__)

def make_error_response(status: int, errors: list[str]) -> flask.Response:
    assert status != RESPONSE_SUCCESS, f"{RESPONSE_SUCCESS} is reserved for success"
    result = flask.jsonify({'status': status, 'errors': errors})
    return result

def make_success_response(dict_result: typing.Any) -> flask.Response:
    result = flask.jsonify({'status': RESPONSE_SUCCESS, 'result': dict_result})
    return result

def get_json_from_flask_request(request: flask.Request) -> GetJSONFromFlaskRequest:
    # Get JSON from request
    result: GetJSONFromFlaskRequest = GetJSONFromFlaskRequest()
    try:
        json_dict = typing.cast(dict[str, typing.Any] | None, json.loads(request.data))
        if json_dict is None:
            result.err_msg = "JSON failed to be parsed"
        else:
            result.json = json_dict
    except Exception as e:
        result.err_msg = f'JSON failed to be parsed: {e}'

    return result

def make_get_all_payments_hash(version: int, master_pkey: nacl.signing.VerifyKey, unix_ts_ms: int, history: bool) -> bytes:
    hasher: hashlib.blake2b = backend.make_blake2b_hasher()
    hasher.update(version.to_bytes(length=1, byteorder='little'))
    hasher.update(bytes(master_pkey))
    hasher.update(unix_ts_ms.to_bytes(length=8, byteorder='little'))
    hasher.update(history.to_bytes(length=1, byteorder='little'))
    result: bytes = hasher.digest()
    return result

def init(testing_mode: bool, db_path: str, db_path_is_uri: bool, server_x25519_skey: nacl.public.PrivateKey) -> flask.Flask:
    result                                                      = flask.Flask(__name__)
    result.config['TESTING']                                    = testing_mode
    result.config[FLASK_CONFIG_DB_PATH_KEY]                     = db_path
    result.config[FLASK_CONFIG_DB_PATH_IS_URI_KEY]              = db_path_is_uri
    result.config[onion_req.FLASK_CONFIG_ONION_REQ_X25519_SKEY] = server_x25519_skey
    result.register_blueprint(flask_blueprint)
    result.register_blueprint(onion_req.flask_blueprint_v4)
    return result

@flask_blueprint.route(FLASK_ROUTE_ADD_PRO_PAYMENT, methods=['POST'])
def add_pro_payment():
    # Get JSON from request
    get: GetJSONFromFlaskRequest = get_json_from_flask_request(flask.request)
    if len(get.err_msg):
        return make_error_response(status=1, errors=[get.err_msg])

    # Extract values from JSON
    err                                         = base.ErrorSink()
    version:          int                       = base.json_dict_require_int(d=get.json,   key='version',       err=err)
    master_pkey:      str                       = base.json_dict_require_str(d=get.json,   key='master_pkey',   err=err)
    rotating_pkey:    str                       = base.json_dict_require_str(d=get.json,   key='rotating_pkey', err=err)
    master_sig:       str                       = base.json_dict_require_str(d=get.json,   key='master_sig',    err=err)
    rotating_sig:     str                       = base.json_dict_require_str(d=get.json,   key='rotating_sig',  err=err)
    payment_tx:       dict[str, base.JSONValue] = base.json_dict_require_obj(d=get.json,   key='payment_tx',    err=err)
    payment_provider: int                       = base.json_dict_require_int(d=payment_tx, key='provider',      err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Parse and validate values
    if version != 0:
        err.msg_list.append(f'Unrecognised version passed: {version}')
    base.verify_payment_provider(payment_provider=payment_provider, err=err)

    # Build payment TX
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    user_payment          = backend.AddProPaymentUserTransaction()
    user_payment.provider = base.PaymentProvider(payment_provider)
    if user_payment.provider == base.PaymentProvider.GooglePlayStore:
        user_payment.google_payment_token = base.json_dict_require_str(d=payment_tx, key='google_payment_token', err=err)
    elif user_payment.provider == base.PaymentProvider.iOSAppStore:
        user_payment.apple_tx_id = base.json_dict_require_str(d=payment_tx, key='apple_tx_id', err=err)

    # Parse other components
    master_pkey_bytes   = base.hex_to_bytes(hex=master_pkey,   label='Master public key',      hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    rotating_pkey_bytes = base.hex_to_bytes(hex=rotating_pkey, label='Rotating public key',    hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    master_sig_bytes    = base.hex_to_bytes(hex=master_sig,    label='Master key signature',   hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)
    rotating_sig_bytes  = base.hex_to_bytes(hex=rotating_sig,  label='Rotating key signature', hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Submit the payment to the DB
    with open_db_from_flask_request_context(flask.current_app) as db:
        unix_ts_ms: int = base.round_unix_ts_ms_to_next_day(int(time.time() * 1000))
        if base.DEV_BACKEND_MODE:
            unix_ts_ms = int(time.time() * 1000)

        proof                                                         = backend.add_pro_payment(sql_conn      = db.sql_conn,
                                                  version             = version,
                                                  signing_key         = db.runtime.backend_key,
                                                  redeemed_unix_ts_ms = unix_ts_ms,
                                                  master_pkey         = nacl.signing.VerifyKey(master_pkey_bytes),
                                                  rotating_pkey       = nacl.signing.VerifyKey(rotating_pkey_bytes),
                                                  payment_tx          = user_payment,
                                                  master_sig          = master_sig_bytes,
                                                  rotating_sig        = rotating_sig_bytes,
                                                  err                 = err)

    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    result = make_success_response(dict_result=proof.to_dict())
    return result

def open_db_from_flask_request_context(flask_app: flask.Flask) -> backend.OpenDBAtPath:
    assert FLASK_CONFIG_DB_PATH_KEY        in flask.current_app.config
    assert FLASK_CONFIG_DB_PATH_IS_URI_KEY in flask.current_app.config
    db_path        = typing.cast(str, flask_app.config[FLASK_CONFIG_DB_PATH_KEY])
    db_path_is_uri = typing.cast(bool, flask_app.config[FLASK_CONFIG_DB_PATH_IS_URI_KEY])
    result         = backend.OpenDBAtPath(db_path, db_path_is_uri)
    return result

@flask_blueprint.route(FLASK_ROUTE_GET_PRO_PROOF, methods=['POST'])
def get_pro_proof() -> flask.Response:
    # Get JSON from request
    get: GetJSONFromFlaskRequest = get_json_from_flask_request(flask.request)
    if len(get.err_msg):
        return make_error_response(status=1, errors=[get.err_msg])

    # Extract values from JSON
    err                = base.ErrorSink()
    version:       int = base.json_dict_require_int(d=get.json, key='version',       err=err)
    master_pkey:   str = base.json_dict_require_str(d=get.json, key='master_pkey',   err=err)
    rotating_pkey: str = base.json_dict_require_str(d=get.json, key='rotating_pkey', err=err)
    unix_ts_ms:    int = base.json_dict_require_int(d=get.json, key='unix_ts_ms',    err=err)
    master_sig:    str = base.json_dict_require_str(d=get.json, key='master_sig',    err=err)
    rotating_sig:  str = base.json_dict_require_str(d=get.json, key='rotating_sig',  err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Parse and validate values
    if version != 0:
        err.msg_list.append(f'Unrecognised version passed: {version}')
    master_pkey_bytes   = base.hex_to_bytes(hex=master_pkey,   label='Master public key',      hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    rotating_pkey_bytes = base.hex_to_bytes(hex=rotating_pkey, label='Rotating public key',    hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    master_sig_bytes    = base.hex_to_bytes(hex=master_sig,    label='Master key signature',   hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)
    rotating_sig_bytes  = base.hex_to_bytes(hex=rotating_sig,  label='Rotating key signature', hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)

    # Validate the timestamp is within 5 minutes of the current time (mitigate replay attacks)
    UNIX_TS_MS_THRESHOLD: int = 60 * 5 * 1000;
    now:                  int = int(time.time() * 1000)
    max_unix_ts_ms:       int = now + UNIX_TS_MS_THRESHOLD
    min_unix_ts_ms:       int = now - UNIX_TS_MS_THRESHOLD

    if unix_ts_ms < min_unix_ts_ms:
        err.msg_list.append(f'Nonce timestamp is too far in the past: {unix_ts_ms} (min {min_unix_ts_ms})')

    if unix_ts_ms > max_unix_ts_ms:
        err.msg_list.append(f'Nonce timestamp is too far in the future: {unix_ts_ms} (max {max_unix_ts_ms})')

    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Request proof from the backend
    with open_db_from_flask_request_context(flask.current_app) as db:
        proof = backend.get_pro_proof(sql_conn       = db.sql_conn,
                                      version        = version,
                                      signing_key    = db.runtime.backend_key,
                                      gen_index_salt = db.runtime.gen_index_salt,
                                      master_pkey    = nacl.signing.VerifyKey(master_pkey_bytes),
                                      rotating_pkey  = nacl.signing.VerifyKey(rotating_pkey_bytes),
                                      unix_ts_ms     = unix_ts_ms,
                                      master_sig     = master_sig_bytes,
                                      rotating_sig   = rotating_sig_bytes,
                                      err            = err)

    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    result = make_success_response(dict_result=proof.to_dict())
    return result

@flask_blueprint.route(FLASK_ROUTE_GET_PRO_REVOCATIONS, methods=['POST'])
def get_pro_revocations():
    # Get JSON from request
    get: GetJSONFromFlaskRequest = get_json_from_flask_request(flask.request)
    if len(get.err_msg):
        return make_error_response(status=1, errors=[get.err_msg])

    # Extract values from JSON
    err          = base.ErrorSink()
    version: int = base.json_dict_require_int(d=get.json, key='version', err=err)
    ticket:  int = base.json_dict_require_int(d=get.json, key='ticket',  err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Parse and validate values
    if version != 0:
        err.msg_list.append(f'Unrecognised version passed: {version}')
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    revocation_items:  list[dict[str, str | int]] = []
    revocation_ticket: int = 0
    with open_db_from_flask_request_context(flask.current_app) as db:
        revocation_ticket = backend.get_revocation_ticket(db.sql_conn)
        if ticket < revocation_ticket:
            with base.SQLTransaction(db.sql_conn) as tx:
                list_it: collections.abc.Iterator[tuple[int, int]] = backend.get_pro_revocations_iterator(tx)
                for row in list_it:
                    gen_index:         int   = row[0]
                    expiry_unix_ts_ms: int   = row[1]
                    gen_index_hash:    bytes = backend.make_gen_index_hash(gen_index=gen_index, gen_index_salt=db.runtime.gen_index_salt)
                    assert gen_index < db.runtime.gen_index
                    assert len(db.runtime.gen_index_salt) == hashlib.blake2b.SALT_SIZE
                    revocation_items.append({
                        'expiry_unix_ts_ms': base.round_unix_ts_ms_to_next_day(expiry_unix_ts_ms),
                        'gen_index_hash':    gen_index_hash.hex(),
                    })

    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    result = make_success_response(dict_result={'version': 0, 'ticket': revocation_ticket, 'items': revocation_items})
    return result

# TODO: we need to add the user_errors table changes to any endpoints that need to report a generic error to a user
@flask_blueprint.route(FLASK_ROUTE_GET_PRO_STATUS, methods=['POST'])
def get_pro_payments():
    # Get JSON from request
    get: GetJSONFromFlaskRequest = get_json_from_flask_request(flask.request)
    if len(get.err_msg):
        return make_error_response(status=1, errors=[get.err_msg])

    # Extract values from JSON
    err               = base.ErrorSink()
    version:     int  = base.json_dict_require_int(d=get.json,  key='version',     err=err)
    master_pkey: str  = base.json_dict_require_str(d=get.json,  key='master_pkey', err=err)
    master_sig:  str  = base.json_dict_require_str(d=get.json,  key='master_sig',  err=err)
    unix_ts_ms:  int  = base.json_dict_require_int(d=get.json,  key='unix_ts_ms',  err=err)
    history:     bool = base.json_dict_require_bool(d=get.json, key='history',     err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Parse and validate values
    if version != 0:
        err.msg_list.append(f'Unrecognised version passed: {version}')
    master_pkey_bytes = base.hex_to_bytes(hex=master_pkey, label='Master public key',    hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    master_sig_bytes  = base.hex_to_bytes(hex=master_sig,  label='Master key signature', hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)

    # Validate timestamp
    # TODO: We _could_ track the last GET_ALL_PAYMENTS_MAX_TIMESTAMP_DELTA_S seconds worth of
    # requests to completely reject replay attacks if we cared enough but onion requests probably
    # suffice to mask the ability to replay a query.
    timestamp_delta: float = (time.time() * 1000) - float(unix_ts_ms)
    if abs(timestamp_delta) >= GET_ALL_PAYMENTS_MAX_TIMESTAMP_DELTA_MS:
        err.msg_list.append(f'Timestamp is too old to permit retrieval of payments, delta was {timestamp_delta}ms')

    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Validate the signature
    master_pkey_nacl      = nacl.signing.VerifyKey(master_pkey_bytes)
    hash_to_verify: bytes = make_get_all_payments_hash(version=version, master_pkey=master_pkey_nacl, unix_ts_ms=unix_ts_ms, history=history)
    try:
        _ = master_pkey_nacl.verify(smessage=hash_to_verify, signature=master_sig_bytes)
    except Exception as e:
        err.msg_list.append('Signature failed to be verified')
        return make_error_response(status=1, errors=err.msg_list)

    items:           list[dict[str, str | int | bool]] = []
    user_pro_status: UserProStatus                     = UserProStatus.NeverBeenPro
    auto_renewing                                      = False
    expiry_unix_ts_ms                                  = 0
    grace_period_duration_ms                           = 0
    with open_db_from_flask_request_context(flask.current_app) as db:
        with base.SQLTransaction(db.sql_conn) as tx:
            get_user: backend.GetUserAndPayments = backend.get_user_and_payments(tx=tx, master_pkey=master_pkey_nacl)
            grace_period_duration_ms = get_user.grace_period_duration_ms
            expiry_unix_ts_ms        = get_user.expiry_unix_ts_ms
            auto_renewing            = get_user.auto_renewing
            has_payments             = False
            for row in get_user.payments_it:
                # NOTE: If the user has at-least one payment, we mark them as being expired
                # initially and every payment we come across, if they have a redeemed payment
                # in their current history, we report them as active.
                if not has_payments:
                    user_pro_status = UserProStatus.Expired
                    has_payments    = True

                faux_row_id                                             = 0
                row_tuple: tuple[int, *backend.SQLTablePaymentRowTuple] = (faux_row_id, *row)
                payment:   backend.PaymentRow                           = backend.payment_row_from_tuple(row_tuple)

                # NOTE: We do not return unredeemed payments. This payment token/tx IDs are
                # confidential until the user actually registers the token themselves which they
                # should witness from the payment provider independently from us so there should be
                # no need to reveal this to the user until they've confirmed their own receipt of
                # it.
                if payment.status == base.PaymentStatus.Unredeemed:
                    continue

                # NOTE: Collect the payment if history was requested
                if history:
                    if payment.payment_provider == base.PaymentProvider.GooglePlayStore:
                        items.append({
                            'status':                               int(payment.status.value),
                            'plan':                                 int(payment.plan.value),
                            'payment_provider':                     int(payment.payment_provider.value),
                            'auto_renewing':                        payment.auto_renewing,
                            'unredeemed_unix_ts_ms':                payment.unredeemed_unix_ts_ms,
                            'redeemed_unix_ts_ms':                  payment.redeemed_unix_ts_ms if payment.redeemed_unix_ts_ms else 0,
                            'expiry_unix_ts_ms':                    payment.expiry_unix_ts_ms,
                            'grace_period_duration_ms':             payment.grace_period_duration_ms,
                            'platform_refund_expiry_unix_ts_ms':    payment.platform_refund_expiry_unix_ts_ms,
                            'revoked_unix_ts_ms':                   payment.revoked_unix_ts_ms if payment.revoked_unix_ts_ms else 0,
                            'google_payment_token':                 payment.google_payment_token,
                            'google_order_id':                      payment.google_order_id,
                        })
                    elif payment.payment_provider == base.PaymentProvider.iOSAppStore:
                        items.append({
                            'status':                               int(payment.status.value),
                            'plan':                                 int(payment.plan.value),
                            'payment_provider':                     int(payment.payment_provider.value),
                            'auto_renewing':                        payment.auto_renewing,
                            'unredeemed_unix_ts_ms':                payment.unredeemed_unix_ts_ms,
                            'redeemed_unix_ts_ms':                  payment.redeemed_unix_ts_ms if payment.redeemed_unix_ts_ms else 0,
                            'expiry_unix_ts_ms':                    payment.expiry_unix_ts_ms,
                            'grace_period_duration_ms':             payment.grace_period_duration_ms,
                            'platform_refund_expiry_unix_ts_ms':    payment.platform_refund_expiry_unix_ts_ms,
                            'revoked_unix_ts_ms':                   payment.revoked_unix_ts_ms if payment.revoked_unix_ts_ms else 0,
                            'apple_original_tx_id':                 payment.apple.original_tx_id,
                            'apple_tx_id':                          payment.apple.tx_id,
                            'apple_web_line_order_id':              payment.apple.web_line_order_tx_id,
                        })

                # NOTE: Determine pro status if it is a relevant
                if payment.status == base.PaymentStatus.Redeemed:
                    user_pro_status = UserProStatus.Active

                # NOTE: If we determine that the user is active and the user didn't request for
                # history, we can early terminate the loop as we've found what we wanted (their pro
                # status).
                if not history and user_pro_status == UserProStatus.Active:
                    break

    result = make_success_response(dict_result={
        'version':                  0,
        'status':                   int(user_pro_status.value),
        'auto_renewing':            auto_renewing,
        'expiry_unix_ts_ms':        expiry_unix_ts_ms,
        'grace_period_duration_ms': grace_period_duration_ms if auto_renewing else 0,
        'items':                    items
    })
    return result
