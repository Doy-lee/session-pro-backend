'''
Overview
  This file is the HTTP layer which declares the functions that serve the routes
  for interacting with the Session Pro Backend. These routes are registered onto
  a Flask application which enable the endpoints for the server.

  The role of this layer is to intercept and sanitize the HTTP request,
  extracting the JSON into valid, strongly typed (to Python's best ability)
  types that can be passed into the backend.

  The backend is responsible for further validation of the request such as
  signature verification and consistency against the state of the DB. If
  successful the result is returned back to this layer and piped back to the
  user in the HTTP response.

API
  All response endpoints follow the basic structure for success and failure
  respectively:

  { "status": 0, "result": { <content...> }, "version": 0}                          // On success
  { "status": 1, "errors": [ "1st reason for error", "2nd reason for error", ... ]} // On failure

  Which means that calling code should conditionally handle a root level
  `result` or `msg` type payload based on the status. `200` for success and
  non-`200` for failures.

  All routes accept v4 onion requests under the endpoint /oxen/lsrpc/v4

  /add_pro_payment
    Description
      Register a new payment identified by a 32 byte hash of the payment token
      received by the third-party store (e.g.: Google Play Store) to the Session
      Pro backend. The hash of the token is defined as:

        hash = blake2b32(person='SeshProBackend', payment_token)

      The master public key `master_pkey` should be the deterministically
      derived Ed25519 public key from the user's Session Account seed. The
      rotating public key `rotating_pkey` should be an independent Ed25519 key
      that will be authorised to use the proof.

      The embedded `master_sig` and `rotating_sig` signature must sign over a
      32 byte hash of the request components (in little endian):

        hash = blake2b32(person='SeshProBackend', version || master_pkey || rotating_pkey || payment_token_hash)

      This request will fail if the Session Pro backend has not witnessed the
      equivalent hashed payment token independently from the storefront that the
      payment originally came from.

    Request
      version:       1 byte, current version of the request which should be 0
      master_pkey:   32 byte Ed25519 public key derived deterministic from the
                     Session Account seed in hex
      rotating_pkey: 32 byte Ed25519 public key to pair to the pro proof in hex
      payment_token: 32 byte hash of the payment token to register that the
                     caller receives by purchasing a Session Pro subscription
      master_sig:    64 byte signature over the hash of the contents of the
                     request proving that the user knows the secret component
                     to the `master_pkey` and hence the caller is authorised to
                     pair a new `rotating_pkey` to this payment
      rotating_sig:  64 byte signature over the contents of the request proving
                     that the user knows the secret component to the
                     `rotating_pkey`

    Response
      expiry_unix_ts_s: 8 byte unix timestamp of when the proof will expire
      gen_index_hash:   32 byte hash of the internal generation index that has
                        been allocated to the user.
      rotating_pkey:    32 byte Ed25519 public key authorised to use the proof
      sig:              64 byte signature over the proof, signed by the Session
                        Pro backend allowing third-parties to verify that the
                        proof was generated by a authoritative backend.

    Example
      Request
      {
        "version": 0,
        "master_pkey": "077deae803d9b55c6b75e36729cb2034ad459d9ff85f821905b5eddb0d48cc60",
        "rotating_pkey": "3cf5193d27a91dd6f53ba30f032135688d8c5f168dee76c4d6206778c862597e",
        "payment_token": "d0cce0ee860616d20cd0ddce86782607331530d628fa994c84689eb40b92be2c",
        "master_sig": "f56c5f685ce6ab7a3775ce581b9e634fbd6358dab085698ccb3ba125c19dda341f8c7a5497268f1fb39874df4e6e4d6552cf984a3d50976b2004f8723d505707",
        "rotating_sig": "fcbe180c96d6b563ae50db48418f7b292d952dcbcdad78a09e74274024a2d79d148d4c16fc52eda2994f78887d4ec95e38e38d2f10547cae03efd41c409a3e01"
      }

      Response
      {
        "result": {
          "expiry_unix_ts_s": 1761004800,
          "gen_index_hash": "a89e5ca2b7c0d36da920b88ae7f4c833f26a41df6291649d2e11aea81217fe72",
          "rotating_pkey": "3cf5193d27a91dd6f53ba30f032135688d8c5f168dee76c4d6206778c862597e",
          "sig": "90db1086e810606cceafb9641584434a711a3989863b270b5a2e6dd9ed44d90996da8c7b0f0d457836dbe21ab41f66f964786817b7a1da398974a5db12e38702",
          "version": 0
        },
        "status": 0
      }

  /get_pro_proof
    Description
      Pair a new `rotating_pkey` to a pre-existing Session Pro payment,
      generating a new proof that can be attached to messages to enable
      entitlement to Pro features on the Session Protocol. The `master_pkey`
      public key must currently have an active subscription/payment associated
      with it for this request to succeed.

      The embedded `master_sig` and `rotating_sig` signature must sign over a
      32 byte hash of the request components (in little endian):

        hash = blake2b32(person='SeshProBackend', version || master_pkey || rotating_pkey || unix_ts_s)

      Once the response has been received, the caller should store the proof
      offline and embed it into their messages on the Session Protocol, signing
      the message with their rotating secret key for other users to validate the
      proof and receive entitlement to Session Pro features.

      The generated proof is signed by the Session Pro Backend. The public keys
      of the backend will be published to allow third parties to authorise the
      validity of a proof's origin.

    Request
      version:       1 byte, current version of the request which should be 0
      master_pkey:   32 byte Ed25519 public key derived deterministic from the
                     Session Account seed in hex
      rotating_pkey: 32 byte Ed25519 public key to pair to the pro proof in hex
      unix_ts_s:     8 byte current unix timestamp in seconds
      master_sig:    64 byte signature over the hash of the contents of the
                     request proving that the user knows the secret component
                     to the `master_pkey` and hence the caller is authorised to
                     pair a new `rotating_pkey` to the payment associated with
                     the `master_pkey`.
      rotating_sig:  64 byte signature over the contents of the request proving
                     that the user knows the secret component to the
                     `rotating_pkey`.

    Response
      expiry_unix_ts_s: 8 byte unix timestamp of when the proof will expire
      gen_index_hash:   32 byte hash of the internal generation index that has
                        been allocated to the user.
      rotating_pkey:    32 byte Ed25519 public key authorised to use the proof
      sig:              64 byte signature over the proof, signed by the Session
                        Pro backend allowing third-parties to verify that the
                        proof was generated by a authoritative backend.

    Examples
      Request
      {
        "version": 0,
        "master_pkey": "2a87bf679678fe7ccad36ae081de58ee327f1a6706d1f2b2ecda52219b7ee8bf",
        "rotating_pkey": "67917f7507c58880c50e249afecb2fe4a236d422c7e05b04d4fbf46e30c965d5",
        "unix_ts_s": 1755648412,
        "master_sig": "76e02d201fad147a318aa798196bf9880bf4425f529e24bb25af34a4181365ef7591ae066b31aded05e3b67370892f381910fcaf3c2ffb5be13cca389a572108",
        "rotating_sig": "74ffec4d91caf777d439f2f34a1c7375ff746ae798181bf357050f7848fd8b7f100a933b61e15f13cacdbd6028b37bc1f2a4d8888b2b04a6e5d7e51b38dd360e"
      }

      Response
      {
        "result": {
          "expiry_unix_ts_s": 1758412800,
          "gen_index_hash": "084563482babfdf1acda66fcef7c70ad835e148ab98f26371ce9e4abef6104d7",
          "rotating_pkey": "67917f7507c58880c50e249afecb2fe4a236d422c7e05b04d4fbf46e30c965d5",
          "sig": "a1ea79c2a274afc0a61e5946976297b42e1dcfdbde29f007c8fe43d2e616fc7e5db5865d05212e392a6395fabe1ed69f976fb19c25f4640df5b89a5870739e0e",
          "version": 0
        },
        "status": 0
      }

  /get_pro_revocations
    Description
      Retrieve the list of revoked Session Pro Proofs. Proofs are signed can be
      validated offline in perpetuity until expiry. There are situations where
      a current circulating and valid proof can be invalidated (for example a
      user has refunded their subscription). The Session Pro backend maintains
      the list of proofs that callers can retrieve to reject proofs that
      circulating on the network.

      This endpoint accepts a `ticket` which represents the current iteration of
      the revocation list. The Session Pro backend increments the ticket
      monotonically with each change to the revocation list. The caller submits
      their latest known `ticket` (which initially will be 0) and in the
      response the latest `ticket` known by the backend will be returned.

      By having the caller cache the ticket and reuse it in subscequent
      requests, the backend will only return the revocation list contents if the
      user's `ticket` is different from the backend's ticket.

      A revocation identifies a Session Pro proof using the `gen_index_hash` of
      the proof. This `gen_index_hash` is shared across all proofs for a user
      that were generated using the same payment, in other words there can be
      more than one proof circulating with this `gen_index_hash`. Callers must
      take care to reject all proofs they witness that match the
      `gen_index_hash` irrespective of any other common information in the proof.

      Note that expired proofs do not get revoked and will not show up in this
      list. It's the caller's responsibility to reject proofs that have expired
      by checking the expiry timestamp. Hence this endpoint is recommended to be
      called every hour from the caller's startup time as revocations are only
      created in exceptional circumstances.

    Request
      version: 1 byte, current version of the request which should be 0
      ticket:  4 byte monotonic integer that represents the current iteration of
               the revocation list held by the caller. Initially callers will
               set this to 0 if they do not know the latest ticket. In
               subsequent requests the latest known `ticket` should be passed in
               so that the backend only returns the updated revocation list if
               the contents of said list has changed.

    Response
      ticket:  4 byte integer of the latest ticket for the current revocation
               list of the Session Pro backend. If this value is the same as the
               request's `ticket` then the list will be empty as there are no
               changes to the revocation list.
      list:    Array of revocations, can be empty if there are no revocations or
               the request ticket is the latest ticket managed by the backend.
        expiry_unix_ts_s: 8 byte unix timestamp indicating when the Session Pro
                           Proof identified by its `gen_index_hash` should be
                           rejected until.
        gen_index_hash: 32 byte hash of the Session Pro proof that has been
                        revoked.

    Examples
      Request
      { "version": 0, "ticket": 0 }

      Response
      {
        "result": {
          "list": [
            { "expiry_unix_ts_s": 1758412800, "gen_index_hash": "3ab824a62d2b6004449d44962383294a5e6e833d6ed491930fbba726a2569c68" }
          ],
          "ticket": 1,
          "version": 0
        },
        "status": 0
      }

  /get_pro_payments
    Description
      Retrieve the list of current and historical payments associated with the
      Session Pro master public key. The returned list is in descending order
      from the date that the payment was registered (e.g.: newest payment to
      oldest).

      This request is paginated, initially the caller should pass the 0th page.
      The response will have the total number of pages at which the caller can
      query more pages if there are any to retrieve more payments.

      The embedded `master_sig` signature must sign over the 32 byte hash of the
      requests contents (in little endian):

        hash = blake2b32(person='SeshProBackend', version || master_pkey || unix_ts_s || page)

    Request
      version:     1 byte, current version of the request which should be 0
      master_pkey: 32 byte Ed25519 public key derived deterministic from the
                   Session Account seed in hex to get payments for
      master_sig:  64 byte signature over the hash of the contents of the
                   request proving that the user knows the secret component
                   to the `master_pkey` and hence the caller is authorised to
                   get payments for this key.
      unix_ts_s:   8 byte unix timestamp of the current time
      page:        4 byte integer for which page of results to get payments for.
                   Initially this should be set to 0, the response will indciate
                   how many pages there are.

    Response
      version:  1 byte, current version of the response which should be 0
      pages:    4 byte integer indicating the total number of pages starting
                from 0
      payments: 4 byte integer indicating the total number of payments associated
                with the `master_pkey`
      list:     Array of payments associated with `master_pkey`. Payments are
                returned in descending order by the payment date
        activation_unix_ts_s:    8 byte unix timestamp indicating if the payment
                                 is has been activated to enable entitlement to
                                 Session Pro before. 0 if the payment has never
                                 been activated (e.g.: This account has another
                                 subscription that is active already and being
                                 consumed first, or, the payment was refunded
                                 before it could be activated e.t.c).
        archive_unix_ts_s:       8 byte unix timestamp indicating when the
                                 payment was archived (either due to refunds or
                                 revocation). This value is 0 if a payment
                                 has not been archived yet (e.g.: has not been
                                 activated and elapsed, nor refunded).
        creation_unix_ts_s:      8 byte unix timestamp indicating when the
                                 payment was registered. This timestamp is
                                 rounded up to the next day boundary from the
                                 actual registration date.
        subscription_duration_s: 4 byte integer indicating the length of the
                                 subscription payment in seconds.
        payment_token_hash:      32 byte hash of the payment token that is
                                 associated with this payment.

    Examples
      Request
      {
        "version": 0,
        "master_pkey": "8ddc57b457fca85d2184813ea18a048f64a35ab0e693d4a0a3e4f8ee87ff3360",
        "master_sig": "37495dfab72772ebf4e4bf213b0a1c46e8e044ef3e4360ff8ef04ee8a7daf2178a716447de6f938d0e7865be31735fb2db2d1213dc35c02dfe253aac77fb2a0d",
        "timestamp": 1755653705,
        "page": 0
      }

      Response
      {
        "result": {
          "list": [
            {
              "activation_unix_ts_s": 1755734400,
              "archive_unix_ts_s": 0,
              "creation_unix_ts_s": 1755734400,
              "payment_token_hash": "d7fc28f52efe9487fbc5c9aa27d006c2e119c94f6a1787963a0c64775afd8363",
              "subscription_duration_s": 2592000
            },
            {
              "activation_unix_ts_s": 0,
              "archive_unix_ts_s": 0,
              "creation_unix_ts_s": 1755734400,
              "payment_token_hash": "425b428ac2857a7fa4f045f8c6055536e679253e22c0b4c003bb6b970792b697",
              "subscription_duration_s": 2592000
            }
          ],
          "pages": 1,
          "payments": 2,
          "version": 0
        },
        "status": 0
      }
'''

import flask
import typing
import time
import nacl.signing
import nacl.bindings
import nacl.public
import collections.abc
import hashlib
import json

import base
import backend
from vendor import onion_req

class GetJSONFromFlaskRequest:
    json:    dict[str, typing.Any] = {}
    err_msg: str                   = ''

# Keys stored in the flask app config dictionary that can be retrieved within
# a request to get the path to the SQLite DB to load and use for that request.
CONFIG_DB_PATH_KEY        = 'session_pro_backend_db_path'
CONFIG_DB_PATH_IS_URI_KEY = 'session_pro_backend_db_path_is_uri'

# Name of the endpoints exposed on the server
ROUTE_ADD_PRO_PAYMENT     = '/add_pro_payment'
ROUTE_GET_PRO_PROOF       = '/get_pro_proof'
ROUTE_GET_PRO_REVOCATIONS = '/get_pro_revocations'
ROUTE_GET_PRO_PAYMENTS    = '/get_pro_payments'

RESPONSE_SUCCESS          = 0

# How many seconds can the timestamp in the get all payments route can drift
# from the current server's timestamp before it's flat out rejected
GET_ALL_PAYMENTS_MAX_TIMESTAMP_DELTA_S = 5

# The object containing routes that you register onto a Flask app to turn it
# into an app that accepts Session Pro Backend client requests.
flask_blueprint = flask.Blueprint('session-pro-backend-blueprint', __name__)

def make_error_response(status: int, errors: list[str]) -> flask.Response:
    assert status != RESPONSE_SUCCESS, f"{RESPONSE_SUCCESS} is reserved for success"
    result = flask.jsonify({'status': status, 'errors': errors})
    return result

def make_success_response(dict_result: dict[str, str | int]) -> flask.Response:
    result = flask.jsonify({'status': RESPONSE_SUCCESS, 'result': dict_result})
    return result

def get_json_from_flask_request(request: flask.Request) -> GetJSONFromFlaskRequest:
    # Get JSON from request
    result: GetJSONFromFlaskRequest = GetJSONFromFlaskRequest()
    try:
        json_dict = typing.cast(dict[str, typing.Any] | None, json.loads(request.data))
        if json_dict is None:
            result.err_msg = "JSON failed to be parsed"
        else:
            result.json = json_dict
    except Exception as e:
        result.err_msg = str(e)

    return result

def make_get_all_payments_hash(version: int, master_pkey: nacl.signing.VerifyKey, unix_ts_s: int, page: int) -> bytes:
    hasher: hashlib.blake2b = backend.make_blake2b_hasher()
    hasher.update(version.to_bytes(length=1, byteorder='little'))
    hasher.update(bytes(master_pkey))
    hasher.update(unix_ts_s.to_bytes(length=8, byteorder='little'))
    hasher.update(page.to_bytes(length=4, byteorder='little'))
    result: bytes = hasher.digest()
    return result

def init(testing_mode: bool, db_path: str, db_path_is_uri: bool, server_x25519_skey: nacl.public.PrivateKey) -> flask.Flask:
    result                                                      = flask.Flask(__name__)
    result.config['TESTING']                                    = testing_mode
    result.config[CONFIG_DB_PATH_KEY]                           = db_path
    result.config[CONFIG_DB_PATH_IS_URI_KEY]                    = db_path_is_uri
    result.config[onion_req.FLASK_CONFIG_ONION_REQ_X25519_SKEY] = server_x25519_skey
    result.register_blueprint(flask_blueprint)
    result.register_blueprint(onion_req.flask_blueprint_v4)
    return result

@flask_blueprint.route(ROUTE_ADD_PRO_PAYMENT, methods=['POST'])
def add_pro_payment():
    # Get JSON from request
    get: GetJSONFromFlaskRequest = get_json_from_flask_request(flask.request)
    if len(get.err_msg):
        return make_error_response(status=1, errors=[get.err_msg])

    # Extract values from JSON
    err                = base.ErrorSink()
    version:       int = base.dict_require(d=get.json, key='version',       default_val=0,  err_msg="Missing version from body",             err=err)
    master_pkey:   str = base.dict_require(d=get.json, key='master_pkey',   default_val='', err_msg="Missing master public key from body",   err=err)
    rotating_pkey: str = base.dict_require(d=get.json, key='rotating_pkey', default_val='', err_msg="Missing rotating public key from body", err=err)
    payment_token: str = base.dict_require(d=get.json, key='payment_token', default_val='', err_msg="Missing payment token from body",       err=err)
    master_sig:    str = base.dict_require(d=get.json, key='master_sig',    default_val='', err_msg="Missing master signature from body",    err=err)
    rotating_sig:  str = base.dict_require(d=get.json, key='rotating_sig',  default_val='', err_msg="Missing rotating signature from body",  err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Parse and validate values
    if version != 0:
        err.msg_list.append(f'Unrecognised version passed: {version}')
        nacl.signing.SigningKey
    master_pkey_bytes   = base.hex_to_bytes(hex=master_pkey,   label='Master public key',      hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    rotating_pkey_bytes = base.hex_to_bytes(hex=rotating_pkey, label='Rotating public key',    hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    payment_token_bytes = base.hex_to_bytes(hex=payment_token, label='Payment token',          hex_len=backend.BLAKE2B_DIGEST_SIZE * 2,              err=err)
    master_sig_bytes    = base.hex_to_bytes(hex=master_sig,    label='Master key signature',   hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)
    rotating_sig_bytes  = base.hex_to_bytes(hex=rotating_sig,  label='Rotating key signature', hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Submit the payment to the DB
    with open_db_from_flask_request_context(flask.current_app) as db:
        creation_unix_ts_s: int = base.round_unix_ts_to_next_day(int(time.time()))
        proof                   = backend.add_pro_payment(sql_conn           = db.sql_conn,
                                                          version            = version,
                                                          signing_key        = db.runtime.backend_key,
                                                          creation_unix_ts_s = creation_unix_ts_s,
                                                          master_pkey        = nacl.signing.VerifyKey(master_pkey_bytes),
                                                          rotating_pkey      = nacl.signing.VerifyKey(rotating_pkey_bytes),
                                                          payment_token_hash = payment_token_bytes,
                                                          master_sig         = master_sig_bytes,
                                                          rotating_sig       = rotating_sig_bytes,
                                                          err                = err)

    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    result = make_success_response(dict_result=proof.to_dict())
    return result

def open_db_from_flask_request_context(flask_app: flask.Flask) -> backend.OpenDBAtPath:
    assert CONFIG_DB_PATH_KEY        in flask.current_app.config
    assert CONFIG_DB_PATH_IS_URI_KEY in flask.current_app.config
    db_path        = typing.cast(str, flask_app.config[CONFIG_DB_PATH_KEY])
    db_path_is_uri = typing.cast(bool, flask_app.config[CONFIG_DB_PATH_IS_URI_KEY])
    result         = backend.OpenDBAtPath(db_path, db_path_is_uri)
    return result

@flask_blueprint.route(ROUTE_GET_PRO_PROOF, methods=['POST'])
def get_pro_proof() -> flask.Response:
    # Get JSON from request
    get: GetJSONFromFlaskRequest = get_json_from_flask_request(flask.request)
    if len(get.err_msg):
        return make_error_response(status=1, errors=[get.err_msg])

    # Extract values from JSON
    err                = base.ErrorSink()
    version:       int = base.dict_require(d=get.json, key='version',       default_val=0,  err_msg="Missing version from body",             err=err)
    master_pkey:   str = base.dict_require(d=get.json, key='master_pkey',   default_val='', err_msg="Missing master public key from body",   err=err)
    rotating_pkey: str = base.dict_require(d=get.json, key='rotating_pkey', default_val='', err_msg="Missing rotating public key from body", err=err)
    unix_ts_s:     int = base.dict_require(d=get.json, key='unix_ts_s',     default_val=0,  err_msg="Missing unix timestamp from body",      err=err)
    master_sig:    str = base.dict_require(d=get.json, key='master_sig',    default_val='', err_msg="Missing master signature from body",    err=err)
    rotating_sig:  str = base.dict_require(d=get.json, key='rotating_sig',  default_val='', err_msg="Missing rotating signature from body",  err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Parse and validate values
    if version != 0:
        err.msg_list.append(f'Unrecognised version passed: {version}')
    master_pkey_bytes   = base.hex_to_bytes(hex=master_pkey,   label='Master public key',      hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    rotating_pkey_bytes = base.hex_to_bytes(hex=rotating_pkey, label='Rotating public key',    hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    master_sig_bytes    = base.hex_to_bytes(hex=master_sig,    label='Master key signature',   hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)
    rotating_sig_bytes  = base.hex_to_bytes(hex=rotating_sig,  label='Rotating key signature', hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Request proof from the backend
    with open_db_from_flask_request_context(flask.current_app) as db:
        proof = backend.get_pro_proof(sql_conn       = db.sql_conn,
                                      version        = version,
                                      signing_key    = db.runtime.backend_key,
                                      gen_index_salt = db.runtime.gen_index_salt,
                                      master_pkey    = nacl.signing.VerifyKey(master_pkey_bytes),
                                      rotating_pkey  = nacl.signing.VerifyKey(rotating_pkey_bytes),
                                      unix_ts_s      = unix_ts_s,
                                      master_sig     = master_sig_bytes,
                                      rotating_sig   = rotating_sig_bytes,
                                      err            = err)

    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    result = make_success_response(dict_result=proof.to_dict())
    return result

@flask_blueprint.route(ROUTE_GET_PRO_REVOCATIONS, methods=['POST'])
def get_pro_revocations():
    # Get JSON from request
    get: GetJSONFromFlaskRequest = get_json_from_flask_request(flask.request)
    if len(get.err_msg):
        return make_error_response(status=1, errors=[get.err_msg])

    # Extract values from JSON
    err          = base.ErrorSink()
    version: int = base.dict_require(d=get.json, key='version', default_val=0, err_msg="Missing version from body",          err=err)
    ticket:  int = base.dict_require(d=get.json, key='ticket',  default_val=0, err_msg="Missing revocation ticket from body", err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Parse and validate values
    if version != 0:
        err.msg_list.append(f'Unrecognised version passed: {version}')
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    revocation_list:   list[dict[str, str | int]] = []
    revocation_ticket: int = 0
    with open_db_from_flask_request_context(flask.current_app) as db:
        revocation_ticket = backend.get_revocation_ticket(db.sql_conn)
        if ticket < revocation_ticket:
            with base.SQLTransaction(db.sql_conn) as tx:
                list_it: collections.abc.Iterator[tuple[int, int]] = backend.get_pro_revocations_iterator(tx)
                for row in list_it:
                    gen_index:        int = row[0]
                    expiry_unix_ts_s: int = row[1]
                    gen_index_hash: bytes = backend.make_gen_index_hash(gen_index=gen_index, gen_index_salt=db.runtime.gen_index_salt)
                    assert gen_index < db.runtime.gen_index
                    assert len(db.runtime.gen_index_salt) == hashlib.blake2b.SALT_SIZE
                    revocation_list.append({
                        'expiry_unix_ts_s': expiry_unix_ts_s,
                        'gen_index_hash':   gen_index_hash.hex(),
                    })

    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    result = make_success_response(dict_result={'version': 0, 'ticket': revocation_ticket, 'list': revocation_list})
    return result

@flask_blueprint.route(ROUTE_GET_PRO_PAYMENTS, methods=['POST'])
def get_pro_payments():
    # Get JSON from request
    get: GetJSONFromFlaskRequest = get_json_from_flask_request(flask.request)
    if len(get.err_msg):
        return make_error_response(status=1, errors=[get.err_msg])

    # Extract values from JSON
    err              = base.ErrorSink()
    version:     int = base.dict_require(d=get.json, key='version',     default_val=0,  err_msg="Missing version from body",           err=err)
    master_pkey: str = base.dict_require(d=get.json, key='master_pkey', default_val='', err_msg="Missing master public key from body", err=err)
    master_sig:  str = base.dict_require(d=get.json, key='master_sig',  default_val='', err_msg="Missing master signature from body",  err=err)
    unix_ts_s:   int = base.dict_require(d=get.json, key='unix_ts_s',   default_val=0,  err_msg="Missing unix timestamp from body",    err=err)
    page:        int = base.dict_require(d=get.json, key='page',        default_val=0,  err_msg="Missing page from body",              err=err)
    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Parse and validate values
    if version != 0:
        err.msg_list.append(f'Unrecognised version passed: {version}')
    master_pkey_bytes = base.hex_to_bytes(hex=master_pkey,   label='Master public key',      hex_len=nacl.bindings.crypto_sign_PUBLICKEYBYTES * 2, err=err)
    master_sig_bytes  = base.hex_to_bytes(hex=master_sig,    label='Master key signature',   hex_len=nacl.bindings.crypto_sign_BYTES * 2,          err=err)

    # Validate timestamp
    # TODO: We _could_ track the last GET_ALL_PAYMENTS_MAX_TIMESTAMP_DELTA_S seconds worth of
    # requests to completely reject replay attacks if we cared enough but onion requests probably
    # suffice to mask the ability to replay a query.
    timestamp_delta: float = time.time() - float(unix_ts_s)
    if abs(timestamp_delta) >= GET_ALL_PAYMENTS_MAX_TIMESTAMP_DELTA_S:
        err.msg_list.append(f'Timestamp is too old to permit retrieval of payments, delta was {timestamp_delta}s')

    if len(err.msg_list):
        return make_error_response(status=1, errors=err.msg_list)

    # Validate the signature
    master_pkey_nacl      = nacl.signing.VerifyKey(master_pkey_bytes)
    hash_to_verify: bytes = make_get_all_payments_hash(version=version, master_pkey=master_pkey_nacl, unix_ts_s=unix_ts_s, page=page)
    try:
        _ = master_pkey_nacl.verify(smessage=hash_to_verify, signature=master_sig_bytes)
    except Exception as e:
        err.msg_list.append('Signature failed to be verified')
        return make_error_response(status=1, errors=err.msg_list)

    total_payments: int                        = 0
    total_pages:    int                        = 0
    item_list:      list[dict[str, str | int]] = []
    with open_db_from_flask_request_context(flask.current_app) as db:
        total_payments = backend.get_pro_payments_count(db.sql_conn, master_pkey=master_pkey_nacl)
        total_pages    = int(total_payments / backend.ALL_PAYMENTS_PAGINATION_SIZE)
        offset         = page * backend.ALL_PAYMENTS_PAGINATION_SIZE
        with base.SQLTransaction(db.sql_conn) as tx:
            list_it: collections.abc.Iterator[tuple[int, int, int, bytes, int]] = \
                    backend.get_pro_payments_iterator(tx=tx, master_pkey=master_pkey_nacl, offset=offset)
            for row in list_it:
                subscription_duration_s: int   = row[0]
                creation_unix_ts_s:      int   = row[1]
                activation_unix_ts_s:    int   = row[2]
                payment_token_hash:      bytes = row[3]
                archive_unix_ts_s:       int   = row[4]

                item_list.append({
                    'subscription_duration_s': subscription_duration_s,
                    'creation_unix_ts_s':      creation_unix_ts_s,
                    'activation_unix_ts_s':    activation_unix_ts_s,
                    'payment_token_hash':      payment_token_hash.hex(),
                    'archive_unix_ts_s':       archive_unix_ts_s,
                })

    result = make_success_response(dict_result={'version': 0, 'pages': total_pages, 'payments': total_payments, 'list': item_list})
    return result
