# Session Pro Backend

A server powered by Python, Flask and uWSGI to manage the lifetime of a Session
Pro subscription for Session users such as:

- Registering payments for Session Pro subscriptions
- Producing crytographic proofs to entitle cryptographic keys to use Session Pro
  features on the Session protocol
- Pruning expired and revoke cryptographic proofs
- Authorising new cryptographic keys for a pre-existing subscription

And so forth.

# Getting started

## Options

Set the following environment variables to customise the behaviour of the
backend:

```
# Set the location to store the database of the backend to
SESH_PRO_BACKEND_DB_PATH=<path/to/db>.db (default: ./backend.db)

# Pretty print the contents of the tables in the database to standard out and
# exit
SESH_PRO_BACKEND_PRINT_TABLES=[0|1] (default: 0)
```

## Build and run

```bash
# Install dependencies
python -m pip install -r requirements.txt

# Run backend w/ a local Flask server in debug mode
python -m flask --app main run --debug

# Another example: as above, but on port 8888 with the DB stored in the current
# working directory at ./data/pro.db
SESH_PRO_BACKEND_DB_PATH=./data/pro.db python -m flask --app main run --debug --port 8888

# Run the tests
python -m pytest test.py

# For running in production we use UWSGI which run multiple instances of the
# Flask app with process lifecycle management, the following command is
# suitable.
#
# Note that the following runs it on a local UWSGI server. If you wish to run
# this from behind a reverse proxy, you want to use (--http-socket) to defer the
# routing of requests to something like nginx or Caddy see this link for more
# details:
#
#   https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html#putting-behind-a-full-webserver
#   https://uwsgi-docs.readthedocs.io/en/latest/HTTP.html
#
# Or alternatively see how oxen-observer in our ecosystem is configured for
# a reasonable real-world example:
#
#   https://github.com/oxen-io/oxen-observer
#
# Run the backend w/ local UWSGI on port 8000 with 4 processes (i.e. 4 HTTP request
# handlers) with the DB stored in the current working directory at ./data/pro.db
#
# Threads must be enabled (--enable-threads) on UWSGI. By default UWSGI does not
# enable the Python GIL so threads generated by the application will never run.
# Our backend spawns one long-running thread for expiring rows in the DB, this
# needs to be running to maintain the integrity of the DB.
#
# Enable `py-call-osafterfork` is essential and makes the spawned child
# processes respect OS level signals. This lets us catch SIGINT issued from the
# master UWSGI instance and propagate it down to our expiring rows thread or
# otherwise the application locks up on exit as the thread will never get
# terminated.
#
# (It may be possible to replace this with the injected uwsgi.signals Python
# module by UWSGI when it launches the backend. However that leaks UWSGI
# implementation detail into the backend and also it's a good idea that child
# processes follow UNIX conventions as you'd expect them to in the first place).
#
# Die on terminate (--die-on-term) similar to `py-call-osafterfork` restores
# UNIX convention in that a SIGTERM should kill the process. UWSGI hijacks this
# and reloads the process. This is the defined behaviour until UWSGI v2.1.
#
# Strict (--strict) and need app (--need-app) abort startup unless all
# configuration options are valid and there's a valid application for UWSGI to
# launch from the process. Any misconfiguration essentially aborts startup.
#
# Vacuum (--vacuum) cleans up any temporary files like sockets that UWSGI
# creates.
#
# Process name prefix (--procname-prefix) assigns a human readable name as the
# process name in the kernel.
SESH_PRO_BACKEND_DB_PATH=./data/pro.db uwsgi \
  --http 127.0.0.1:8000 \
  --master \
  --wsgi-file main.py \
  --callable flask_app \
  --processes 4 \
  --enable-threads \
  --py-call-osafterfork \
  --die-on-term \
  --strict \
  --need-app \
  --vacuum \
  --procname-prefix \"SESH Pro Backend \"
```
